Vu Doan
COM SCI 31 Franz Hall 1260

a. Notable Obstacles
    - There were a lot of edge cases to think about like if n2 > n1 in functions like subsequence or if n was negative
    - The other edge case was when n, n1, or n2 were 0, some functions returned 0 while other returned -1
    - It was difficult thinking how to partition the split function because I thought I had to sort it at first but I could just arrange the string less than splitter behind a index
        - It was difficult because I was trying to get the extra credit
        - I also took a lot of time making a alphabetical sorter because I forgot that c++ automatically checks if a string is bigger
b. List of Test Data
    int repeat(string a[], int n);
    string elements[8] = {"fire", "water", "earth", "air", "light", "dark", "ice", "rock"}
    - repeat(elements, 8); Normal case -> returns 8
        - elements - > {"firefire", "waterwater", "earthearth", "airair", "lightlight", "darkdark", "iceice", "rockrock"}
    - repeat (elements, 4); Different index amount - > returns 4
        elements - > {"firefire", "waterwater", "earthearth", "airair", "light", "dark", "ice", "rock"}
    - repeat(elements, 0); No elements checked -> returns 0
    - repeat(elements, -3); Negative index -> returns -1

    int detectMatch(const string a[], int n, string target);
    string elements[8] = {"fire", "water", "earth", "air", "light", "dark", "ice", "rock"}
    - detectMatch(elements, 8, "water"); Normal case -> returns 1
    - detectMatch(elements, 5, "dark"); Checked only 5 elements -> returns -1
    - detectMatch(elements,  0, "rock"); No elements checked -> returns -1
    - detectMatch(elements, -5, "fire"); Negative index -> returns -1

    int detectMax(const string a[], int n);
    string elements[8] = {"fire", "water", "earth", "air", "light", "dark", "ice", "rock"}
    - detectMax(elements, 8); Normal case -> returns 1 ("water" is alphabetically largest)
    - detectMax(elements, 0); No elements examined -> returns -1
    - detectMax(elements, -8); Negative index -> returns -1

    int circleLeft(string a[], int n, int pos);
    string elements[8] = {"fire", "water", "earth", "air", "light", "dark", "ice", "rock"}
    - circleLeft(elements, 8, 2); Normal case -> returns 2
        - elements -> {"fire", "water", "air", "light", "dark", "ice", "rock", "earth"}
    - circleLeft(elements, 8, 0); First element moves to end -> returns 0
        - elements -> {"water", "earth", "air", "light", "dark", "ice", "rock", "fire"}
    - circleLeft(elements, 8, 10); Out of bounds position -> returns -1
    - circleLeft(elements, -3, 1); Negative index -> returns -1


    int enumerateRuns(const string a[], int n);
    string elements[8] = {"fire", "fire", "water", "earth", "earth", "earth", "rock", "rock"};
    - enumerateRuns(elements, 7); Normal case -> returns 4
    - enumerateRuns(elements, 0); No elements examined -> returns 0
    - enumerateRuns(elements, -2); Negative index -> returns -1

    int flip(string a[], int n);
    string elements[8] = {"fire", "water", "earth", "air", "light", "dark", "ice", "rock"}
    - flip(elements, 8); Normal case -> returns 8
        - elements -> {"rock", "ice", "dark", "light", "air", "earth", "water", "fire"};
    - flip(elements, 4); Different index amount -> returns 4
        - elements -> {"air", "earth" , "water", "fire" , "light", "dark", "ice", "rock"}
    - flip(elements, 0); No elements examined -> returns 0
        - elements -> {"fire", "water", "earth", "air", "light", "dark", "ice", "rock"}
    - flip(elements, -5); Negative index -> returns -1

    int detectDifference(const string a1[], int n1, const string a2[], int n2);
    string elements1[8] = {"fire", "water", "earth", "air", "light", "dark", "ice", "rock"}
    string elements2[5] = {"fire", "water", "dark", "air", "light"}
    - detectDifference(elements1, 5, elements2, 5); Normal case -> returns 2
    - detectDifference(elements1, 4, elements2, 2); Shorter second index -> returns 2
    - detectDifference(elements1, -4, elements2, 5); Negative index -> returns -1
    - detectDifference(elements, 8, elements2, 0); No elements to detect -> returns 0
    - detectDifference(elements, 0, elements2, 5); No elements examined -> returns 0

    int subsequence(const string a1[], int n1, const string a2[], int n2);
    string elements[8] = {"fire", "water", "earth", "air", "light", "dark", "ice", "rock"};
    string sub1[3] = {"earth", "air", "light"};
    string sub2[2] = {"water", "rock"};
    - subsequence(elements, 8, sub1, 3); Found case -> returns 2
    - subsequence(elements, 8, sub2, 2); Not found case -> returns -1
    - subsequence(elements, 8, sub1, 0); Empty subsequence -> returns 0
    - subsequence(elements, 0, sub1, 2); Longer subarray then array (n2 > n1) -> returns -1
    - subsequence(elements, 0, sub1, 0); Both arrays empty -> returns 0

    int detectAny(const string a1[], int n1, const string a2[], int n2);
    string elements1[6] = {"fire", "earth", "ice", "light", "rock", "dark"};
    string elements2[3] = {"storm", "ice", "cloud"};
    - detectAny(elements1, 6, elements2, 3); Match at index 2 -> returns 2
    - detectAny(elements1, 0, elements2, 3); Empty first array -> returns -1
    - detectAny(elements1, 6, elements2, 0); Empty second array -> returns -1
    - detectAny(elements, 0, elements, 0); Empty first and second array -> returns -1
    - detectAny(elements1, -2, elements2, 3); Negative size -> returns -1

    int split(string a[], int n, string splitter);
    string elements[8] = {"fire", "water", "earth", "air", "light", "dark", "ice", "rock"};
    - split(elements, 8, "light"); Normal case -> returns 4
    - split(elements, 8, "dirt"); Normal case -> returns 2
    - split(elements, 4, "apple"); Normal case -> returns 1
    - split(elements, 0, "light"); No elements -> returns 0
    - split(elements, -4, "light"); Negative case -> returns -1

    