Vu Doan
COM SCI 31 Franz Hall 1260

a. Notable Obstacles
    - There were a lot of edge cases to think about like if n2 > n1 in functions like subsequence or if n was negative
    - The other edge case was when n, n1, or n2 were 0, some functions returned 0 while other returned -1
    - It was difficult thinking how to partition the split function because I thought I had to sort it at first but I could just arrange the string less than splitter behind a index

b. List of Test Data
    int repeat(string a[], int n);
    string elements[8] = {"fire", "water", "earth", "air", "light", "dark", "ice", "rock"}
    - repeat(elements, 4); Normal case -> returns 4
    - repeat(elements, 0); No elements checked -> returns 0
    - repeat(elements, -3); Negative index case -> returns -1

    int detectMatch(const string a[], int n, string target);
    string elements[8] = {"fire", "water", "earth", "air", "light", "dark", "ice", "rock"}
    - detectMatch(elements, 8, "water"); Normal case -> returns 1
    - detectMatch(elements, 5, "dark"); Checked only 5 elements -> returns -1
    - detectMatch(elements,  0, "rock"); No elements checked -> returns -1
    - detectMatch(elements, -5, "fire"); Negative index case -> returns -1

    int detectMax(const string a[], int n);
    string elements[8] = {"fire", "water", "earth", "air", "light", "dark", "ice", "rock"}
    - detectMax(elements, 8); Normal case -> returns 1 ("water" is alphabetically largest)
    - detectMax(elements, 0); No elements examined -> returns -1
    - detectMax(elements, -8); Negative index case -> returns -1

    int circleLeft(string a[], int n, int pos);
    string elements[8] = {"fire", "water", "earth", "air", "light", "dark", "ice", "rock"}
    - circleLeft(elements, 8, 2); Normal case -> returns 2
        - elements -> {"fire", "water", "air", "light", "dark", "ice", "rock", "earth"}
    - circleLeft(elements, 8, 0); First element moves to end -> returns 0
        - elements -> {"water", "earth", "air", "light", "dark", "ice", "rock", "fire"}
    - circleLeft(elements, 8, 10); Out of bounds position case -> returns -1
    - circleLeft(elements, -3, 1); Negative index case -> returns -1


    int enumerateRuns(const string a[], int n);
    string elements[8] = {"fire", "fire", "water", "earth", "earth", "earth", "rock", "rock"};
    - enumerateRuns(elements, 7); Normal case -> returns 4
    - enumerateRuns(elements, 0); No elements examined -> returns 0
    - enumerateRuns(elements, -2); Negative case -> returns -1

    int flip(string a[], int n);
    string elements[8] = {"fire", "water", "earth", "air", "light", "dark", "ice", "rock"}
    - flip(elements, 8); Normal case -> returns 8
    - flip(elements, 0); No elements examined -> returns 0
    - flip(elements, -5); Negative case -> returns -1

    int detectDifference(const string a1[], int n1, const string a2[], int n2);
    string elements1[8] = {"fire", "water", "earth", "air", "light", "dark", "ice", "rock"}
    string elements2[5] = {"fire", "water", "dark", "air", "light"}
    - detectDifference(elements1, 5, elements2, 5); First difference at index 2 -> returns 2
    - detectDifference(elements1, 4, elements2, 2); Shorter second ends -> returns 2
    - detectDifference(elements1, -4, elements2, 5); Negative case -> returns -1
    - detectDifference(elements, 8, elements2, 0); No elements to detect -> returns -1
    - detectDifference(elements, 0, elements2, 5); No elements examined -> -1

    int subsequence(const string a1[], int n1, const string a2[], int n2);
    - 

    int detectAny(const string a1[], int n1, const string a2[], int n2);
    -

    int split(string a[], int n, string splitter);
    -

    